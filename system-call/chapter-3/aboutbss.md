##aboutbss

###本文讨论BSS段在可执行文件中的地位与作用

####what?

BSS: 又名未初始化的数据段，主要保存为初始化的全局变量和静态局部变量。


####why?

对于一个程序而言，在经历过预处理阶段后，进入编译阶段，此时生成我们已经了解的.o 文件，此时对于BSS段而言是不分配空间的。接着程序进入到链接阶段，首先在这里我们要说明，链接就是将动态库，一些其它的我们需要调用的函数的地址加载到可执行文件中。当可执行文件运行时，它的各个段将自己的内容映射到虚拟地址空间中，例如数据段的数据此时就会被映射到栈段，那么这些数据此是需要开辟空间的，当然值存在的话，自然可以直接映射到内存的虚拟地址空间中，但是如果这个变量是为初始化的，我们就没有必要将它映射到虚拟地址空间中，并且给他开辟空间。

为了减少空间的冗余开辟，我们可以将为初始化的一些变量和已经初始化的变量分开处理，BSS段就再这样的情况下登场了，在过去内存资源有限的情况下更是如此，这也是BSS段遗留至今的原因。

###how

现在我们讨论它是如何实现减少内存消耗的。其实不管怎么说，编译链接其实是为了程序在运行时的优化。所以不论BSS段在目标文件，可执行文件中是否开辟空间都是为在运行时有一个较优的结果。

####在目标文件中

首先看代码
![ss](./image/testc.png)

可见只有一个未初始化的a;

我们现在来看大小
![ss](./image/testo.png)

可见BSS大小为0.

接着我们来看可执行文件的BSS段大小
![ss](./image/test.png)

可以看到这里的BSS段是有大小的，大小为12,我们发现，这个大小是按照一定规律对齐的，首先当BSS 的大小小于4的时候，它直接分配4字节，当BSS大与等与4的时候在4的基础上按照8字节对齐。

接着我们确定BSS段是否占用空间，在可执行文件阶段。
当我们在BSS段放置一个比较大的数组的时候，其实在可执行文件中并没有开辟大小。我们使用size 看到的是逻辑空间大小，不然之间和我们想要减少内存开辟的初衷相违背，所以在ls 看来只是相应的增加了记录的大小而已。

至于ALLOC属性是在加载过程中可能动态开辟的。
